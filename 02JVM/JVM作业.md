# JVM作业

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

### 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存

Java 运行时数据区（内存区域）是 Java 虚拟机为了更加高效地执行 Java 程序而创建的一种内存管理机制。它包含以下几个部分：

- 堆（Heap）：是 Java 虚拟机内存管理中最大的一块，也是存放对象实例和数组的地方。Java 堆可以分为年轻代和老年代，其中年轻代分为 Eden 区和两个 Survivor 区，主要存放新创建的对象，而老年代主要存放长时间存活的对象。
- 虚拟机栈（Java Virtual Machine Stack）：存放 Java 方法执行时的局部变量、操作数栈、动态链接、方法出口等信息。虚拟机栈是线程私有的，每个线程都有自己的虚拟机栈。当一个方法被调用时，Java 虚拟机会为该方法创建一个新的栈帧，该栈帧被压入虚拟机栈，并成为当前的活动栈帧。当方法执行完毕后，将其栈帧弹出虚拟机栈。
- 本地方法栈（Native Method Stack）：与虚拟机栈类似，只不过是为 Java 调用本地方法服务的。本地方法栈也是线程私有的。
- 方法区（Method Area）：存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区是线程共享的运行时内存区域。方法区也可以被称为永久代或元空间，具体名称取决于 Java 虚拟机的版本。在 Java 8 以前，方法区是使用永久代来实现的，但是在 Java 8 中，永久代被替换为了元空间。永久代使用的是JVM内存的一部分。元空间使用JVM以外的物理内存，且只存储类的元信息，而静态变量和运行时常量池都挪到堆中。
- 运行时常量池（Runtime Constant Pool）：是方法区的一部分，存放编译器生成的字面量和符号引用。运行时常量池与类加载器的关系非常密切，每个类都有一个运行时常量池，用于存放该类的常量池信息。
- 直接内存（Direct Memory）：与 Java 堆一样，也是由操作系统管理的内存区域，不过它不受 Java 堆大小的限制，可以使用 NIO 类库来直接操作它。直接内存的使用可以减少 Java 堆和操作系统之间的数据复制次数，提高系统性能。

### 为什么堆内存要分年轻代和老年代？

基于三大分代假说

1. 弱分代假说：绝大多数对象都是朝生夕灭的。
2. 强分代假说：熬过越多此垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用来说只占极少数

堆内存分代的主要目的是基于不同分代中对象的情况，采用不同的垃圾回收算法，提高垃圾回收效率，降低JVM对应用的影响。年轻代大多采用复制算法，老年代大多采用标记清除或标记压缩算法。

## 题目 02- 描述一个 Java 对象的生命周期

### 解释一个对象的创建过程

正常通过new关键字创建一个类的对象的过程主要分为以下几步：

1. new指令：通过new指令开始创建对象。
2. 常量池检查：检查类元信息是否存在，如不存在，尝试加载类，静态变量赋默认值。
3. 类的初始化：静态变量赋实际值，执行表态代码块。
4. 分配内存空间：根据类元信息，确认对象大小，分配内存空间。
5. 内存空间初始化：为成员变量赋默认值。
6. 必要信息设置：对象的头信息（类元信息，哈希码，锁状态，GC分代年龄等）。
7. 对象初始化：执行对象的初始块，执行构造方法。
8. 引用对象：局部变量表中的变量指向对象。

### 解释一个对象的内存分配

对象的内存分配方式

1. 指针碰撞
    
    主要用于新生代，作用于连续规整的内存，将指针向未分配的空间移动对象大小的位置
    
2. 空闲列表
    
    主要用于老年代，作用于不连续不规整的内存，垃圾回收后将空闲内存保存至一个列表，为新对象分配内存里从该列表中选取适合大小的内存地址进行分配。
    

**内存分配安全**

JVM中对多线程的对象内存分配安全问题有两种解决方法：

1. CAS：虚拟机通过乐观锁加失败重试的方式保证内存分配的安全。
2. TLAB(Thread Local Allocate Buffer)：通过给每个线程预先分配单独的内存空间保证内存分配的安全。

### 解释一个对象的销毁过程

一个对象在销毁过程中，至少要经历两次标记过程:

第一次标记：如果对象可达性分析后，发现没有与GC Roots相连接的引用链，那它将会被第一标记

第二次标记：第一次标记后，接着会进行一次筛选。筛选条件为此对象是否有必要执行finalize() 方法。在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。

第二次标记成功的对象将真的会被回收，如果失败则继续存活。

finalize()方法主要用于对象销毁前的资源释放工作，只会被调用一次。

### 对象的 2 种访问方式是什么？

Java 对象有两种访问方式，分别为：

1. 句柄:稳定，对象被移动只要修改句柄中的地址
2. 直接指针:访问速度快，节省了一次指针定位的开销

### 为什么需要内存担保？

内存担保简单来说就是当新对象进入新生代，或新生代进行MinorGC时，新生代无法存放对象，该对象会提前进入老年代，这种机制称之为内存担保。

内存担保主要为了防止新生代内存溢出。

## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

### ParNew 收集器

ParNew收集器是一种使用多线程的新生代收集器，它是Serial收集器的多线程版本。它的主要作用是收集新生代。在年轻代使用标记复制算法进行垃圾回收时，ParNew收集器可以使用多个线程同时扫描和复制对象，从而加快垃圾回收速度。同时，它也能与CMS收集器配合使用，以实现在新生代和老年代的并发收集。

与Serial收集器不同，ParNew收集器可以充分利用多核处理器的优势，提高垃圾回收的效率。它还支持动态调整线程数量和垃圾回收比例，以适应不同的应用场景和硬件环境。

### ParallelScavenge收集器

ParallelScavenge收集器是一种新生代收集器，它也是使用标记复制算法进行垃圾回收。与ParNew收集器不同的是，ParallelScavenge收集器更加注重吞吐量的优化，它可以在多CPU的环境下实现高吞吐量的垃圾回收。

ParallelScavenge收集器通过将内存分为多个区域，每一个区域都是一个线程，每个线程都可以独立地进行垃圾回收，从而充分利用多核CPU的优势。在垃圾回收时，ParallelScavenge收集器会尽量利用可用的CPU资源，以达到最大的垃圾回收吞吐量。

ParallelScavenge收集器的特点：

- 优化吞吐量，适用于后台运行的大型应用程序
- 多线程并行处理，充分利用多核CPU的优势
- 可以通过参数调整垃圾回收时间和吞吐量的比例
- 会产生较长的停顿时间，不适合对响应时间要求较高的应用程序

### ParallelOld 收集器

ParallelOld 收集器是一种并行的老年代垃圾收集器，它是在JDK 1.6时期引入的。它的主要作用是在老年代中使用标记-整理算法进行垃圾回收，其中标记阶段是并行的，而整理阶段则是串行的。在垃圾回收时，它使用多线程来加速垃圾回收的速度，从而减少停顿时间。ParallelOld 收集器是并行收集器的一种，可以与 Parallel Scavenge 收集器一起使用，以充分利用多核 CPU 的优势。

ParallelOld 收集器的特点：

- 充分利用多核 CPU 的优势进行并行垃圾回收
- 高效，适用于大型应用程序
- 可以通过参数调整垃圾回收时间和吞吐量的比例

总之，ParallelOld 收集器是一个强大的垃圾收集器，它通过并行垃圾回收来提高垃圾回收的效率，适用于大型应用程序。同时，它也可以与 Parallel Scavenge 收集器配合使用，以充分利用多核 CPU 的优势。

### CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以“最小化停顿时间”为目标的垃圾收集器。它的主要作用是收集老年代中的垃圾，采用标记-清除算法进行垃圾回收，其中标记和清除阶段都是并发执行的。在垃圾回收时，CMS收集器会尽量减少应用程序的停顿时间，从而提高应用程序的响应速度。

CMS收集器的特点：

- 并发收集，最小化停顿时间
- 高效，适用于大型应用程序
- 可以与ParNew收集器一起使用，以充分发挥并发垃圾回收的优势

由于CMS收集器是并发收集器，它不会在整个垃圾回收过程中暂停应用程序。但是，在标记和清除阶段中，由于需要扫描整个老年代，因此会对应用程序的执行产生一定的影响。此外，由于CMS收集器采用标记-清除算法进行垃圾回收，因此会产生大量的碎片，可能会导致内存不足的问题。

总之，CMS收集器是一种高效的垃圾收集器，它通过并发垃圾回收来最小化应用程序的停顿时间，适用于大型应用程序。同时，它也可以与ParNew收集器一起使用，以充分发挥并发垃圾回收的优势。

### G1 收集器

G1 收集器是一种面向服务端应用的垃圾收集器，它是在JDK 7 Update 4时期引入的。它的主要作用是将整个Java堆分为多个小块（Region），并根据垃圾产生的情况，动态地选择哪些小块需要优先进行垃圾回收。在垃圾回收时，G1收集器会尽量减少应用程序的停顿时间，从而提高应用程序的响应速度。

G1收集器的特点：

- 并发收集，最小化停顿时间
- 可以分区（Region）回收，避免全堆扫描

G1收集器优势在于将Java堆分为多个小块，只处理垃圾最多的小块，从而避免了全堆扫描，降低了垃圾回收的时间。

总之，G1收集器是一种面向服务端应用的垃圾收集器，它通过分步回收和并发垃圾回收来最小化应用程序的停顿时间，适用于大型应用程序。